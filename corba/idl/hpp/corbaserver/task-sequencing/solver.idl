// Copyright (c) 2023 CNRS
// Author: Florent Lamiraux
//

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.

#ifndef HPP_TASK_SEQUENCING_CORBA_SOLVER_HH
#define HPP_TASK_SEQUENCING_CORBA_SOLVER_HH

#include <hpp/common.idl>

module hpp {
  module corbaserver {
    module task_sequencing {
      struct Cluster {
	floatSeq centroid;
	floatSeqSeq points;
      };
      typedef sequence <Cluster> Clusters;

      interface Solver {
        /// Create a solver for several instances of the current robot
        ///
        /// \param nbInstances number of robot instances
        ///
        /// The single robot is the one stored in the problem solver
        void create(in unsigned long nbInstances) raises(Error);

        /// Set error threshold
        void setErrorThreshold(in double threshold) raises(Error);

        /// Set maximal number of iterations
        void setMaxIterations(in long iterations) raises(Error);

        /// Add constraint to one robot
        ///
        /// \param name constraint name
        /// \param index index of robot in the solver
        void addConstraint(in string name, in unsigned long index)
          raises(Error);

        /// Add an explicit equality constraint of a joint between two robots
        ///
        /// \param jointName name of the joint in the robot,
        /// \param index1, index2 indices of the robot instances
        ///
        /// The joint value in index1 instance is copied from the joint values
        /// in index2 instance.
        void addEqualityConstraint(in string jointName, in unsigned long index1,
                                   in unsigned long index2) raises(Error);
        /// Set right hand sides of constraints from an input vector
        ///
        /// Set right hand side of all parameterizable constraints with input
        /// value
        void setRightHandSideFromVector(in floatSeq input) raises(Error);

        /// Solve the set of constraints
        ///
        /// \param input initial guess,
        /// \retval output output of the solver (solution if success, last
        ///         iteration otherwise),
        /// \retval residualError residual error.
        boolean solve(in floatSeq input, out floatSeq output,
                      out floatSeq residualError) raises(Error);
        /// Print the solver in a string
        void display(out string solver) raises(Error);

	/// test isodata
	/// \param points matrix of the coordinates of the points to be clustered
	/// \param nbRows the nb of points
	/// \param nbCols the nb of coordinates of a point
	/// \param c expected nb of clusters
	/// \param nc initial nb of clusters
	/// \param tn min size of a cluster
	/// \param te max variance of a cluster
	/// \param tc min distance between centroids
	/// \param nt max nb of merges per iteration
	/// \param ns max nb of iterations
	/// \param k importance factor of the angle in the task distance measure
	/// \retval result clusters obtained after applying the algorithm
	void testIsoData(in floatSeqSeq points, in long nbRows, in long nbCols,
			 in unsigned long c, in unsigned long nc, in unsigned long tn,
			 in double te, in double tc, in unsigned long nt, in unsigned long ns,
			 in double k,
			 out Clusters result)
	  raises(Error);

	/// \param configs matrix of the configurations
	/// \param clusters matrix of the clusters of configurations per handle
	/// \param jointSpeeds vector of the maximal joint velocities
	/// \param q0 vector of the rest configuration of the robot
	/// \retval distances distance matrix for the given configurations
	void computeDistances(in floatSeqSeq configs, in intSeqSeq clusters,
			      in floatSeq jointSpeeds, in floatSeq q0,
			      out floatSeqSeq distances)
	  raises(Error);

	void setRobotArmIndices(in unsigned long start, in unsigned long size)
	  raises(Error);
      };
    }; // interface Solver
  }; // module task_sequencing
}; // module hpp

#endif // HPP_TASK_SEQUENCING_CORBA_SOLVER_HH


